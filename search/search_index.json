{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>ChromatinHD analyzes single-cell ATAC+RNA data using the raw fragments as input, by automatically adapting the scale at which relevant chromatin changes on a per-position, per-cell, and per-gene basis.</p> <p>Currently, the following models are supported:</p> Pred <p> To learn where and how accessibility is predictive for gene expression </p> Diff <p>To understand the differences in accessibilty between cell types/states</p> Time <p>To learn where and how accessibility is predictive over (pseudo)time</p> Dime <p>To learn the differences in accessibility over (pseudo)time</p>"},{"location":"quickstart/0_install/","title":"Installation","text":"<pre>\n# using pip\npip install chromatinhd\n\n# (soon) using conda\nconda install -c bioconda chromatinhd\n\n# from github\npip install git+https://github.com/DeplanckeLab/ChromatinHD\n</pre> <p>To use the GPU, ensure that a PyTorch version was installed with cuda enabled:</p> In\u00a0[3]: Copied! <pre>import torch\ntorch.cuda.is_available() # should return True\ntorch.cuda.device_count() # should be &gt;= 1\n</pre> import torch torch.cuda.is_available() # should return True torch.cuda.device_count() # should be &gt;= 1 <p>If not, follow the instructions at https://pytorch.org/get-started/locally/. You may have to re-install PyTorch.</p> In\u00a0[\u00a0]: hide_output Copied! <pre>import chromatinhd as chd\n</pre> import chromatinhd as chd"},{"location":"quickstart/0_install/#installation","title":"Installation\u00b6","text":""},{"location":"quickstart/1_data/","title":"Data preparation","text":"In\u00a0[\u00a0]: hide_output Copied! <pre>import chromatinhd as chd\n</pre> import chromatinhd as chd <p>To speed up training and inference, ChromatinHD stores several intermediate files to disk. This includes preprocessed data and models. These will be stored in the example folder.</p> In\u00a0[4]: Copied! <pre>import pathlib\n\ndataset_folder = pathlib.Path(\"example\")\ndataset_folder.mkdir(exist_ok=True)\n</pre> import pathlib  dataset_folder = pathlib.Path(\"example\") dataset_folder.mkdir(exist_ok=True) <p>For this quickstart, we will use a tiny example dataset extracted from the 10X multiome PBMC example data. We'll copy over both the h5ad for the transcriptomics data, and the fragments.tsv for the accessibility data.</p> In\u00a0[7]: Copied! <pre>import pkg_resources\nimport shutil\n\nDATA_PATH = pathlib.Path(\n    pkg_resources.resource_filename(\"chromatinhd\", \"data/examples/pbmc10ktiny/\")\n)\n\n# copy all files from data path to dataset folder\nfor file in DATA_PATH.iterdir():\n    shutil.copy(file, dataset_folder / file.name)\n</pre> import pkg_resources import shutil  DATA_PATH = pathlib.Path(     pkg_resources.resource_filename(\"chromatinhd\", \"data/examples/pbmc10ktiny/\") )  # copy all files from data path to dataset folder for file in DATA_PATH.iterdir():     shutil.copy(file, dataset_folder / file.name) In\u00a0[10]: Copied! <pre>!ls {dataset_folder}\n</pre> !ls {dataset_folder} <pre>fragments.tsv.gz  fragments.tsv.gz.tbi\ttranscriptome.h5ad\n</pre> In\u00a0[14]: Copied! <pre>import scanpy as sc\n\nadata = sc.read(dataset_folder / \"transcriptome.h5ad\")\n</pre> import scanpy as sc  adata = sc.read(dataset_folder / \"transcriptome.h5ad\") In\u00a0[15]: Copied! <pre>transcriptome = chd.data.Transcriptome.from_adata(\n    adata, path=dataset_folder / \"transcriptome\"\n)\n</pre> transcriptome = chd.data.Transcriptome.from_adata(     adata, path=dataset_folder / \"transcriptome\" ) In\u00a0[16]: Copied! <pre>!ls {dataset_folder}/*\n</pre> !ls {dataset_folder}/* <pre>example/fragments.tsv.gz      example/transcriptome.h5ad\nexample/fragments.tsv.gz.tbi\n\nexample/transcriptome:\nadata.pkl  layers  obs.tsv  var.tsv\n</pre> Batch effects <p>       Currently, none of the ChromatinHD models directly supports batch effects, although this will likely be added in the future. If you have batch effects, the current recommended workflow depends on the source of the batch effect:     <ul> <li>If it mainly comes from ambient mRNA, we recommend to use the corrected data. The reason is that this batch effect will likely not be present in the ATAC-seq data.</li> <li>If it mainly comes from biological differences (e.g. cell stress, patient differences, ...), we recommend to use the uncorrected data. The reason is that this batch effect will likely be reflected in the ATAC-seq data as well, given that the genes are truly differentially regulated between the cells.</li> </ul> </p> <p>ChromatinHD defines a set of regions of interest, typically surrounding the one or more transcription start sites of a gene. Given a set of genes from the transcriptomics data and a genome, we can define these regions as follows:</p> <p>We first get the canonical transcripts for each gene.</p> In\u00a0[19]: Copied! <pre>biomart_dataset = chd.biomart.Dataset.from_genome(\"GRCh38\")\ncanonical_transcripts = chd.biomart.get_canonical_transcripts(\n    biomart_dataset, transcriptome.var.index\n)\n</pre> biomart_dataset = chd.biomart.Dataset.from_genome(\"GRCh38\") canonical_transcripts = chd.biomart.get_canonical_transcripts(     biomart_dataset, transcriptome.var.index ) <p>Now we can define the regions around the TSS. In this case we choose -10kb and +10kb around a TSS, although in real situations this will typically be much bigger (e.g. -100kb - +100kb)</p> In\u00a0[20]: Copied! <pre>regions = chd.data.Regions.from_canonical_transcripts(\n    canonical_transcripts,\n    path=dataset_folder / \"regions\",\n    window=[-10000, 10000],\n)\n</pre> regions = chd.data.Regions.from_canonical_transcripts(     canonical_transcripts,     path=dataset_folder / \"regions\",     window=[-10000, 10000], ) In\u00a0[21]: Copied! <pre>!ls -lh {dataset_folder}/*\n</pre> !ls -lh {dataset_folder}/* <pre>-rw-r--r-- 1 wsaelens peak_free_atac 2.0M Jul 21 19:48 example/fragments.tsv.gz\n-rw-r--r-- 1 wsaelens peak_free_atac 4.3K Jul 21 19:48 example/fragments.tsv.gz.tbi\n-rw-r--r-- 1 wsaelens peak_free_atac 2.5M Jul 21 19:48 example/transcriptome.h5ad\n\nexample/clustering:\ntotal 280K\n-rw-r--r-- 1 wsaelens peak_free_atac 1.4K Jul 21 19:49 cluster_info.pkl\n-rw-r--r-- 1 wsaelens peak_free_atac 276K Jul 21 19:49 labels.pkl\n\nexample/regions:\ntotal 8.0K\n-rw-r--r-- 1 wsaelens peak_free_atac 3.4K Jul 21 19:49 coordinates.tsv\n-rw-r--r-- 1 wsaelens peak_free_atac   24 Jul 21 19:49 window.pkl\n\nexample/transcriptome:\ntotal 3.5M\n-rw-r--r-- 1 wsaelens peak_free_atac 2.7M Jul 21 19:49 adata.pkl\ndrwxr-xr-x 2 wsaelens peak_free_atac 4.0K Jul 21 19:49 layers\n-rw-r--r-- 1 wsaelens peak_free_atac 876K Jul 21 19:49 obs.tsv\n-rw-r--r-- 1 wsaelens peak_free_atac 6.1K Jul 21 19:49 var.tsv\n</pre> Gene vs TSS coordinates <p>The coordinates of the canonical transcript often do not correspond to the gene annotation that are used for e.g. RNA-seq analysis. The reason is that gene coordinates are defined based on the largest transcript in both ends.   </p> <p>The fragment file should be indexed.</p> In\u00a0[22]: Copied! <pre>if not (dataset_folder / \"fragments.tsv.gz.tbi\").exists():\n    import subprocess\n\n    subprocess.run(\n        [\n            \"tabix\",\n            dataset_folder / \"fragments.tsv.gz\",\n        ]\n    )\n</pre> if not (dataset_folder / \"fragments.tsv.gz.tbi\").exists():     import subprocess      subprocess.run(         [             \"tabix\",             dataset_folder / \"fragments.tsv.gz\",         ]     ) In\u00a0[23]: Copied! <pre>fragments = chd.data.Fragments.from_fragments_tsv(\n    dataset_folder / \"fragments.tsv.gz\",\n    regions,\n    obs=transcriptome.obs,\n    path=dataset_folder / \"fragments\",\n)\n</pre> fragments = chd.data.Fragments.from_fragments_tsv(     dataset_folder / \"fragments.tsv.gz\",     regions,     obs=transcriptome.obs,     path=dataset_folder / \"fragments\", ) <pre>Processing fragments:   0%|          | 0/50 [00:00&lt;?, ?it/s]</pre> In\u00a0[24]: Copied! <pre>fragments.create_cellxgene_indptr()\n</pre> fragments.create_cellxgene_indptr() In\u00a0[25]: Copied! <pre>!ls {dataset_folder}/*\n</pre> !ls {dataset_folder}/* <pre>example/fragments.tsv.gz      example/transcriptome.h5ad\nexample/fragments.tsv.gz.tbi\n\nexample/clustering:\ncluster_info.pkl  labels.pkl\n\nexample/fragments:\ncellxgene_indptr.pkl  coordinates.pkl  mapping.pkl  obs.tsv  regions  var.tsv\n\nexample/regions:\ncoordinates.tsv  window.pkl\n\nexample/transcriptome:\nadata.pkl  layers  obs.tsv  var.tsv\n</pre> <p>The final set of data are the training folds that will be used to train - and test - the model. For basic models this is simply done by randomly sampling cells.</p> In\u00a0[26]: Copied! <pre>folds = chd.data.folds.Folds(dataset_folder / \"folds\" / \"5x1\").sample_cells(\n    fragments, 5, 1\n)\n</pre> folds = chd.data.folds.Folds(dataset_folder / \"folds\" / \"5x1\").sample_cells(     fragments, 5, 1 ) <p>Although not needed for every model, for interpretation it can be helpful to store some clustering.</p> In\u00a0[\u00a0]: Copied! <pre>clustering = chd.data.Clustering.from_labels(\n    adata.obs[\"celltype\"], path=dataset_folder / \"clustering\"\n)\n</pre> clustering = chd.data.Clustering.from_labels(     adata.obs[\"celltype\"], path=dataset_folder / \"clustering\" ) In\u00a0[\u00a0]: Copied! <pre>!ls {clustering.path}\n</pre> !ls {clustering.path} <pre>cluster_info.pkl  labels.pkl\n</pre> <p>We can perform a motif scan within our windows.</p> In\u00a0[\u00a0]: Copied! <pre>motifscan = chd.data.Motifscan.from_regions(\n    regions, path=dataset_folder / \"motifscan\"\n)\n</pre> motifscan = chd.data.Motifscan.from_regions(     regions, path=dataset_folder / \"motifscan\" ) In\u00a0[\u00a0]: Copied! <pre>!ls {motifscan.path}\n</pre> !ls {motifscan.path} <pre>cluster_info.pkl  labels.pkl\n</pre>"},{"location":"quickstart/1_data/#data-preparation","title":"Data preparation\u00b6","text":""},{"location":"quickstart/1_data/#key-data","title":"Key data\u00b6","text":""},{"location":"quickstart/1_data/#transcriptomics","title":"Transcriptomics\u00b6","text":""},{"location":"quickstart/1_data/#regions-of-interest","title":"Regions of interest\u00b6","text":""},{"location":"quickstart/1_data/#atac-seq","title":"ATAC-seq\u00b6","text":"<p>ChromatinHD simply requires a <code>fragments.tsv</code> file. This contains for each fragment its chromosome, start, end and cell barcode.</p> <ul> <li>When using Cellranger, this file will be produced by the pipeline.</li> <li>If you have a bam file, you can use sinto to create the fragment file</li> </ul>"},{"location":"quickstart/1_data/#training-folds","title":"Training folds\u00b6","text":""},{"location":"quickstart/1_data/#optional-data","title":"Optional data\u00b6","text":""},{"location":"quickstart/1_data/#clusters","title":"Clusters\u00b6","text":""},{"location":"quickstart/1_data/#motif-scan","title":"Motif scan\u00b6","text":""},{"location":"quickstart/2_pred/","title":"ChromatinHD-pred","text":"In\u00a0[\u00a0]: hide_output Copied! <pre>import chromatinhd as chd\nimport matplotlib.pyplot as plt\n</pre> import chromatinhd as chd import matplotlib.pyplot as plt <p>ChromatinHD-pred uses accessibility fragments to predict gene expression. As such, it can detect features such as broad or narrow positioning of fragments, or fragment sizes, that are predictive for gene expression.</p> <p>We first load in all the input data:</p> In\u00a0[221]: Copied! <pre>import pathlib\ndataset_folder = pathlib.Path(\"example\")\nfragments = chd.data.Fragments(dataset_folder / \"fragments\")\ntranscriptome = chd.data.Transcriptome(dataset_folder / \"transcriptome\")\nfolds = chd.data.folds.Folds(dataset_folder / \"folds\" / \"5x1\")\n</pre> import pathlib dataset_folder = pathlib.Path(\"example\") fragments = chd.data.Fragments(dataset_folder / \"fragments\") transcriptome = chd.data.Transcriptome(dataset_folder / \"transcriptome\") folds = chd.data.folds.Folds(dataset_folder / \"folds\" / \"5x1\") <p>The basic ChromatinHD-pred model</p> In\u00a0[222]: Copied! <pre>models = chd.models.pred.model.additive.Models(dataset_folder / \"models\" / \"additive\", reset = True)\n</pre> models = chd.models.pred.model.additive.Models(dataset_folder / \"models\" / \"additive\", reset = True) In\u00a0[\u00a0]: hide_output Copied! <pre>models.train_models(fragments, transcriptome, folds, device = \"cuda\")\n</pre> models.train_models(fragments, transcriptome, folds, device = \"cuda\") <p>We will first check whether the model learned something, by comparing the predictive performance with a baseline</p> In\u00a0[224]: Copied! <pre>gene_cors = models.get_gene_cors(fragments, transcriptome, folds, device = \"cuda\")\ngene_cors[\"symbol\"] = gene_cors.index.map(transcriptome.symbol)\n</pre> gene_cors = models.get_gene_cors(fragments, transcriptome, folds, device = \"cuda\") gene_cors[\"symbol\"] = gene_cors.index.map(transcriptome.symbol) In\u00a0[225]: Copied! <pre>gene_cors.sort_values(\"deltacor\", ascending = False).head(10)\n</pre> gene_cors.sort_values(\"deltacor\", ascending = False).head(10) Out[225]: cor_predicted cor_n_fragments n_fragments deltacor symbol gene ENSG00000100721 0.458880 0.135177 41.2 0.323703 TCL1A ENSG00000169429 0.475118 0.169594 330.6 0.305523 CXCL8 ENSG00000185666 0.302153 0.029521 22.2 0.272632 SYN3 ENSG00000143297 0.312124 0.039584 37.8 0.272540 FCRL5 ENSG00000239264 0.332108 0.070291 286.0 0.261817 TXNDC5 ENSG00000105369 0.532800 0.283968 1820.6 0.248832 CD79A ENSG00000221866 0.307623 0.074430 89.8 0.233193 PLXNA4 ENSG00000173068 0.373886 0.152450 81.6 0.221436 BNC2 ENSG00000156738 0.622245 0.402413 204.6 0.219832 MS4A1 ENSG00000012124 0.610037 0.396753 465.8 0.213284 CD22 In\u00a0[226]: Copied! <pre>import pandas as pd\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize = (4, 4))\n\nfor name, group in gene_cors.iterrows():\n    ax.plot([0, 1], group[[\"cor_n_fragments\", \"cor_predicted\"]], color = \"#3338\", zorder = 0, marker = \"o\", markersize = 2)\nax.boxplot(gene_cors[[\"cor_n_fragments\", \"cor_predicted\"]].values, positions = [0, 1], widths = 0.1, showfliers = False, showmeans = True, meanline = True, meanprops = {\"color\": \"red\", \"linewidth\": 2})\nax.set_xticks([0, 1])\nax.set_xticklabels([\"# fragments\", \"ChromatinHD-pred\"])\nax.set_ylabel(\"$cor$\")\n;\n</pre> import pandas as pd import matplotlib.pyplot as plt  fig, ax = plt.subplots(figsize = (4, 4))  for name, group in gene_cors.iterrows():     ax.plot([0, 1], group[[\"cor_n_fragments\", \"cor_predicted\"]], color = \"#3338\", zorder = 0, marker = \"o\", markersize = 2) ax.boxplot(gene_cors[[\"cor_n_fragments\", \"cor_predicted\"]].values, positions = [0, 1], widths = 0.1, showfliers = False, showmeans = True, meanline = True, meanprops = {\"color\": \"red\", \"linewidth\": 2}) ax.set_xticks([0, 1]) ax.set_xticklabels([\"# fragments\", \"ChromatinHD-pred\"]) ax.set_ylabel(\"$cor$\") ; Out[226]: <pre>''</pre> <p>Note that every gene gains from the ChromatinHD model, even if some only gain a little. The genes with a low $\\Delta cor$ are often those with only a few fragments:</p> In\u00a0[227]: Copied! <pre>fig, ax = plt.subplots(figsize = (4, 4))\nax.scatter(gene_cors[\"n_fragments\"], gene_cors[\"deltacor\"])\nax.set_ylabel(\"$\\\\Delta$ cor\")\nax.set_xlabel(\"# fragments\")\nax.set_xscale(\"log\")\n</pre> fig, ax = plt.subplots(figsize = (4, 4)) ax.scatter(gene_cors[\"n_fragments\"], gene_cors[\"deltacor\"]) ax.set_ylabel(\"$\\\\Delta$ cor\") ax.set_xlabel(\"# fragments\") ax.set_xscale(\"log\") <p>To determine which regions were important for the model to predict gene expression, we will censor fragments from windows of various sizes, and then check whether the model performance on a set of test cells decreased. This functionality is implemented in the <code>GeneMultiWindow</code> class. This will only run the censoring for a subset of genes to speed up interpretation.</p> In\u00a0[228]: Copied! <pre>censorer = chd.models.pred.interpret.MultiWindowCensorer(fragments.regions.window)\ngenemultiwindow = chd.models.pred.interpret.GeneMultiWindow(\n    models.path / \"interpret\" / \"genemultiwindow\"\n)\n</pre> censorer = chd.models.pred.interpret.MultiWindowCensorer(fragments.regions.window) genemultiwindow = chd.models.pred.interpret.GeneMultiWindow(     models.path / \"interpret\" / \"genemultiwindow\" ) In\u00a0[229]: Copied! <pre>genemultiwindow.score(\n    fragments,\n    transcriptome,\n    models,\n    folds,\n    transcriptome.gene_id(\n        [\n            \"CCL4\",\n            \"IL1B\",\n            \"EBF1\",\n            \"PAX5\",\n            \"CD79A\",\n            \"RHEX\",\n        ]\n    ),\n    censorer=censorer,\n)\n</pre> genemultiwindow.score(     fragments,     transcriptome,     models,     folds,     transcriptome.gene_id(         [             \"CCL4\",             \"IL1B\",             \"EBF1\",             \"PAX5\",             \"CD79A\",             \"RHEX\",         ]     ),     censorer=censorer, ) <pre>  0%|          | 0/6 [00:00&lt;?, ?it/s]</pre> In\u00a0[230]: Copied! <pre>genemultiwindow.interpolate()\n</pre> genemultiwindow.interpolate() <pre>  0%|          | 0/6 [00:00&lt;?, ?it/s]</pre> In\u00a0[231]: Copied! <pre>symbol = \"EBF1\"\n\nfig = chd.grid.Figure(chd.grid.Grid(padding_height=0.05))\nwidth = 10\n\nregion = fragments.regions.coordinates.loc[transcriptome.gene_id(symbol)]\npanel_genes = chd.plot.genome.genes.Genes.from_region(region, width=width)\nfig.main.add_under(panel_genes)\n\npanel_pileup = chd.models.pred.plot.Pileup.from_genemultiwindow(\n    genemultiwindow, transcriptome.gene_id(symbol), width=width\n)\nfig.main.add_under(panel_pileup)\n\npanel_predictivity = chd.models.pred.plot.Predictivity.from_genemultiwindow(\n    genemultiwindow, transcriptome.gene_id(symbol), width=width\n)\nfig.main.add_under(panel_predictivity)\n\nfig.plot()\n</pre> symbol = \"EBF1\"  fig = chd.grid.Figure(chd.grid.Grid(padding_height=0.05)) width = 10  region = fragments.regions.coordinates.loc[transcriptome.gene_id(symbol)] panel_genes = chd.plot.genome.genes.Genes.from_region(region, width=width) fig.main.add_under(panel_genes)  panel_pileup = chd.models.pred.plot.Pileup.from_genemultiwindow(     genemultiwindow, transcriptome.gene_id(symbol), width=width ) fig.main.add_under(panel_pileup)  panel_predictivity = chd.models.pred.plot.Predictivity.from_genemultiwindow(     genemultiwindow, transcriptome.gene_id(symbol), width=width ) fig.main.add_under(panel_predictivity)  fig.plot() <p>In a similar fashion we can determine the co-predictivity per position.</p> In\u00a0[216]: Copied! <pre>censorer = chd.models.pred.interpret.WindowCensorer(fragments.regions.window)\ngenepairwindow = chd.models.pred.interpret.GenePairWindow(\n    models.path / \"interpret\" / \"genepairwindow\", reset = True\n)\ngenepairwindow.score(fragments, transcriptome, models, folds, censorer = censorer, genes = transcriptome.gene_id([\"CCL4\"]))\n</pre> censorer = chd.models.pred.interpret.WindowCensorer(fragments.regions.window) genepairwindow = chd.models.pred.interpret.GenePairWindow(     models.path / \"interpret\" / \"genepairwindow\", reset = True ) genepairwindow.score(fragments, transcriptome, models, folds, censorer = censorer, genes = transcriptome.gene_id([\"CCL4\"])) <pre>  0%|          | 0/1 [00:00&lt;?, ?it/s]</pre> <pre>(5, 200, 200)\n</pre> In\u00a0[217]: Copied! <pre>symbol = \"CCL4\"\n\nfig = chd.grid.Figure(chd.grid.Grid(padding_height=0.05))\nwidth = 10\n\n# genes\nregion = fragments.regions.coordinates.loc[transcriptome.gene_id(symbol)]\npanel_genes = chd.plot.genome.genes.Genes.from_region(region, width=width)\nfig.main.add_under(panel_genes)\n\n# pileup\npanel_pileup = chd.models.pred.plot.Pileup.from_genemultiwindow(\n    genemultiwindow, transcriptome.gene_id(symbol), width=width\n)\nfig.main.add_under(panel_pileup)\n\n# predictivity\npanel_predictivity = chd.models.pred.plot.Predictivity.from_genemultiwindow(\n    genemultiwindow, transcriptome.gene_id(symbol), width=width\n)\nfig.main.add_under(panel_predictivity)\n\n# copredictivity\npanel_copredictivity = chd.models.pred.plot.Copredictivity.from_genepairwindow(\n    genepairwindow, transcriptome.gene_id(symbol), width=width\n)\nfig.main.add_under(panel_copredictivity)\n\nfig.plot()\n</pre> symbol = \"CCL4\"  fig = chd.grid.Figure(chd.grid.Grid(padding_height=0.05)) width = 10  # genes region = fragments.regions.coordinates.loc[transcriptome.gene_id(symbol)] panel_genes = chd.plot.genome.genes.Genes.from_region(region, width=width) fig.main.add_under(panel_genes)  # pileup panel_pileup = chd.models.pred.plot.Pileup.from_genemultiwindow(     genemultiwindow, transcriptome.gene_id(symbol), width=width ) fig.main.add_under(panel_pileup)  # predictivity panel_predictivity = chd.models.pred.plot.Predictivity.from_genemultiwindow(     genemultiwindow, transcriptome.gene_id(symbol), width=width ) fig.main.add_under(panel_predictivity)  # copredictivity panel_copredictivity = chd.models.pred.plot.Copredictivity.from_genepairwindow(     genepairwindow, transcriptome.gene_id(symbol), width=width ) fig.main.add_under(panel_copredictivity)  fig.plot() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"quickstart/2_pred/#chromatinhd-pred","title":"ChromatinHD-pred\u00b6","text":""},{"location":"quickstart/2_pred/#train-the-models","title":"Train the models\u00b6","text":""},{"location":"quickstart/2_pred/#some-quality-checks","title":"Some quality checks\u00b6","text":""},{"location":"quickstart/2_pred/#predictivity-per-position","title":"Predictivity per position\u00b6","text":""},{"location":"quickstart/2_pred/#co-predictivity-per-position","title":"Co-predictivity per position\u00b6","text":""},{"location":"quickstart/3_diff/","title":"ChromatinHD-diff","text":"In\u00a0[\u00a0]: hide_output Copied! <pre>import chromatinhd as chd\nimport matplotlib.pyplot as plt\n</pre> import chromatinhd as chd import matplotlib.pyplot as plt <p>ChromatinHD-pred uses accessibility fragments to predict gene expression. As such, it can detect features such as broad or narrow positioning of fragments, or fragment sizes, that are predictive for gene expression.</p> <p>We first load in all the input data:</p> In\u00a0[4]: Copied! <pre>import pathlib\ndataset_folder = pathlib.Path(\"example\")\nfragments = chd.data.Fragments(dataset_folder / \"fragments\")\ntranscriptome = chd.data.Transcriptome(dataset_folder / \"transcriptome\")\nfolds = chd.data.folds.Folds(dataset_folder / \"folds\" / \"5x1\")\nclustering = chd.data.Clustering(dataset_folder / \"clustering\")\n</pre> import pathlib dataset_folder = pathlib.Path(\"example\") fragments = chd.data.Fragments(dataset_folder / \"fragments\") transcriptome = chd.data.Transcriptome(dataset_folder / \"transcriptome\") folds = chd.data.folds.Folds(dataset_folder / \"folds\" / \"5x1\") clustering = chd.data.Clustering(dataset_folder / \"clustering\") <p>The basic ChromatinHD-diff model</p> In\u00a0[7]: Copied! <pre>import chromatinhd.models.diff.model.cutnf\n</pre> import chromatinhd.models.diff.model.cutnf In\u00a0[8]: Copied! <pre>models = chd.models.diff.model.cutnf.Models(dataset_folder / \"models\" / \"cutnf\", reset = True)\n</pre> models = chd.models.diff.model.cutnf.Models(dataset_folder / \"models\" / \"cutnf\", reset = True) In\u00a0[\u00a0]: hide_output Copied! <pre>models.train_models(fragments, clustering, folds, device = \"cuda\", n_epochs = 10, nbins = (256, 128, 64, 32))\n</pre> models.train_models(fragments, clustering, folds, device = \"cuda\", n_epochs = 10, nbins = (256, 128, 64, 32)) <p>Currently, the ChromatinHD-model is purely positional, i.e. it only looks whether Tn5 insertion sites increase or decrease within a region. As such, we can only interpret it positionally:</p> In\u00a0[10]: Copied! <pre>import chromatinhd.models.diff.interpret.genepositional\n</pre> import chromatinhd.models.diff.interpret.genepositional In\u00a0[11]: Copied! <pre>genepositional = chromatinhd.models.diff.interpret.genepositional.GenePositional(\n    path=models.path / \"interpret\" / \"genepositional\"\n)\ngenepositional.score(\n    fragments,\n    clustering,\n    models,\n    folds,\n    force=True,\n)\n</pre> genepositional = chromatinhd.models.diff.interpret.genepositional.GenePositional(     path=models.path / \"interpret\" / \"genepositional\" ) genepositional.score(     fragments,     clustering,     models,     folds,     force=True, ) <pre>  0%|          | 0/50 [00:00&lt;?, ?it/s]</pre> In\u00a0[15]: Copied! <pre>symbol = \"EBF1\"\n\nfig = chd.grid.Figure(chd.grid.Grid(padding_height=0.05, padding_width=0.05))\nwidth = 10\n\nregion = fragments.regions.coordinates.loc[transcriptome.gene_id(symbol)]\npanel_genes = chd.plot.genome.genes.Genes.from_region(region, width=width)\nfig.main.add_under(panel_genes)\n\nplotdata, plotdata_mean = genepositional.get_plotdata(transcriptome.gene_id(symbol))\npanel_differential = chd.models.diff.plot.Differential(\n    plotdata, plotdata_mean, cluster_info = clustering.cluster_info, panel_height = 0.5, width=width\n)\nfig.main.add_under(panel_differential)\n\npanel_expression = chd.models.diff.plot.DifferentialExpression.from_transcriptome(\n    transcriptome = transcriptome, clustering = clustering, gene = transcriptome.gene_id(symbol), panel_height = 0.5\n)\nfig.main.add_right(panel_expression, row = panel_differential)\n\nfig.plot()\n</pre> symbol = \"EBF1\"  fig = chd.grid.Figure(chd.grid.Grid(padding_height=0.05, padding_width=0.05)) width = 10  region = fragments.regions.coordinates.loc[transcriptome.gene_id(symbol)] panel_genes = chd.plot.genome.genes.Genes.from_region(region, width=width) fig.main.add_under(panel_genes)  plotdata, plotdata_mean = genepositional.get_plotdata(transcriptome.gene_id(symbol)) panel_differential = chd.models.diff.plot.Differential(     plotdata, plotdata_mean, cluster_info = clustering.cluster_info, panel_height = 0.5, width=width ) fig.main.add_under(panel_differential)  panel_expression = chd.models.diff.plot.DifferentialExpression.from_transcriptome(     transcriptome = transcriptome, clustering = clustering, gene = transcriptome.gene_id(symbol), panel_height = 0.5 ) fig.main.add_right(panel_expression, row = panel_differential)  fig.plot() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"quickstart/3_diff/#chromatinhd-diff","title":"ChromatinHD-diff\u00b6","text":""},{"location":"quickstart/3_diff/#train-the-models","title":"Train the models\u00b6","text":""},{"location":"quickstart/3_diff/#interpret-positionally","title":"Interpret positionally\u00b6","text":""},{"location":"reference/data/","title":"Data","text":"<p>         Bases: <code>Flow</code></p> <p>Regions, typically centered around a transcription start site</p> Source code in <code>src/chromatinhd/data/regions.py</code> <pre><code>class Regions(Flow):\n\"\"\"\n    Regions, typically centered around a transcription start site\n    \"\"\"\n\n    coordinates = TSV(\"coordinates\", columns=[\"chrom\", \"start\", \"end\"])\n    window = Stored(\"window\")\n\n    @classmethod\n    def from_canonical_transcripts(\n        cls, canonical_transcripts: pd.DataFrame, window: np.ndarray, path: pathlib.Path\n    ):\n        regions = canonical_transcripts[\n            [\"chrom\", \"start\", \"end\", \"ensembl_transcript_id\"]\n        ].copy()\n\n        regions[\"tss\"] = [\n            genes_row[\"start\"] if genes_row[\"strand\"] == +1 else genes_row[\"end\"]\n            for _, genes_row in canonical_transcripts.loc[regions.index].iterrows()\n        ]\n        regions[\"strand\"] = canonical_transcripts[\"strand\"]\n        regions[\"positive_strand\"] = (regions[\"strand\"] == 1).astype(int)\n        regions[\"negative_strand\"] = (regions[\"strand\"] == -1).astype(int)\n        regions[\"chrom\"] = canonical_transcripts.loc[regions.index, \"chrom\"]\n\n        regions[\"start\"] = (\n            regions[\"tss\"]\n            + window[0] * (regions[\"strand\"] == 1)\n            - window[1] * (regions[\"strand\"] == -1)\n        )\n        regions[\"end\"] = (\n            regions[\"tss\"]\n            + window[1] * (regions[\"strand\"] == -1)\n            - window[0] * (regions[\"strand\"] == 1)\n        )\n\n        return cls.create(\n            path=path,\n            coordinates=regions[\n                [\"chrom\", \"start\", \"end\", \"tss\", \"strand\", \"ensembl_transcript_id\"]\n            ],\n            window=window,\n        )\n</code></pre> <p>         Bases: <code>Flow</code></p> <p>Fragments centered around a gene window</p> Source code in <code>src/chromatinhd/data/fragments/fragments.py</code> <pre><code>class Fragments(Flow):\n\"\"\"Fragments centered around a gene window\"\"\"\n\n    regions = Linked(\"regions\")\n\"\"\"regions of the fragments\"\"\"\n\n    coordinates = StoredTorchInt64(\"coordinates\")\n\"\"\"Coordinates of the fragments\"\"\"\n\n    mapping = StoredTorchInt64(\"mapping\")\n\"\"\"Mapping of a fragment to a gene and a cell\"\"\"\n\n    cellxgene_indptr = StoredTorchInt64(\"cellxgene_indptr\")\n\"\"\"Index pointers for each cellxgene combination\"\"\"\n\n    regions = Linked(\"regions\")\n\n    def create_cellxgene_indptr(self):\n        cellxgene = self.mapping[:, 0] * self.n_genes + self.mapping[:, 1]\n\n        if not (cellxgene.diff() &gt;= 0).all():\n            raise ValueError(\n                \"Fragments should be ordered by cell then gene (ascending)\"\n            )\n\n        n_cellxgene = self.n_genes * self.n_cells\n        cellxgene_indptr = torch.nn.functional.pad(\n            torch.cumsum(torch.bincount(cellxgene, minlength=n_cellxgene), 0), (1, 0)\n        )\n        assert self.coordinates.shape[0] == cellxgene_indptr[-1]\n        if not (cellxgene_indptr.diff() &gt;= 0).all():\n            raise ValueError(\n                \"Fragments should be ordered by cell then gene (ascending)\"\n            )\n        self.cellxgene_indptr = cellxgene_indptr\n\n    _genemapping = None\n\n    @property\n    def genemapping(self):\n        if self._genemapping is None:\n            self._genemapping = self.mapping[:, 1].contiguous()\n        return self._genemapping\n\n    _cellmapping = None\n\n    @property\n    def cellmapping(self):\n        if self._cellmapping is None:\n            self._cellmapping = self.mapping[:, 0].contiguous()\n        return self._cellmapping\n\n    var = TSV(\"var\")\n    obs = TSV(\"obs\")\n\n    _n_genes = None\n\n    @property\n    def n_genes(self):\n        if self._n_genes is None:\n            self._n_genes = self.var.shape[0]\n        return self._n_genes\n\n    _n_cells = None\n\n    @property\n    def n_cells(self):\n        if self._n_cells is None:\n            self._n_cells = self.obs.shape[0]\n        return self._n_cells\n\n    @property\n    def local_cellxgene_ix(self):\n        return self.cellmapping * self.n_genes + self.genemapping\n\n    def estimate_fragment_per_cellxgene(self):\n        return math.ceil(self.coordinates.shape[0] / self.n_cells / self.n_genes * 2)\n\n    def create_cut_data(self):\n        cut_coordinates = self.coordinates.flatten()\n        cut_coordinates = (cut_coordinates - self.window[0]) / (\n            self.window[1] - self.window[0]\n        )\n        keep_cuts = (cut_coordinates &gt;= 0) &amp; (cut_coordinates &lt;= 1)\n        cut_coordinates = cut_coordinates[keep_cuts]\n\n        self.cut_coordinates = cut_coordinates\n\n        self.cut_local_gene_ix = self.genemapping.expand(2, -1).T.flatten()[keep_cuts]\n        self.cut_local_cell_ix = self.cellmapping.expand(2, -1).T.flatten()[keep_cuts]\n\n    @property\n    def genes_oi_torch(self):\n        return torch.from_numpy(self.genes_oi).to(self.coordinates.device)\n\n    @property\n    def cells_oi_torch(self):\n        return torch.from_numpy(self.genes_oi).to(self.coordinates.device)\n\n    @classmethod\n    def from_fragments_tsv(\n        cls,\n        fragments_file: typing.Union[pathlib.Path, str],\n        regions: Regions,\n        obs: pd.DataFrame,\n        path: typing.Union[pathlib.Path, str],\n        overwrite=True,\n    ):\n\"\"\"\n        Create a Fragments object from a tsv file\n\n        Parameters:\n            fragments_file:\n                fragments_file of the tsv file\n            path:\n                folder in which the fragments object will be created\n            regions:\n                regions object\n        \"\"\"\n\n        if isinstance(fragments_file, str):\n            fragments_file = pathlib.Path(fragments_file)\n        if isinstance(path, str):\n            path = pathlib.Path(path)\n        if not fragments_file.exists():\n            raise FileNotFoundError(f\"File {fragments_file} does not exist\")\n        if not overwrite and path.exists():\n            raise FileExistsError(f\"Folder {path} already exists\")\n        path.mkdir(parents=True, exist_ok=True)\n\n        # region information\n        var = pd.DataFrame(index=regions.coordinates.index)\n        var[\"ix\"] = np.arange(var.shape[0])\n\n        n_genes = var.shape[0]\n\n        # cell information\n        obs[\"ix\"] = np.arange(obs.shape[0])\n        cell_to_cell_ix = obs[\"ix\"].to_dict()\n\n        n_cells = obs.shape[0]\n\n        # load fragments tabix\n        import pysam\n\n        fragments_tabix = pysam.TabixFile(str(fragments_file))\n\n        coordinates_raw = []\n        mapping_raw = []\n\n        for i, (gene, promoter_info) in tqdm.tqdm(\n            enumerate(regions.coordinates.iterrows()),\n            total=regions.coordinates.shape[0],\n            leave=False,\n            desc=\"Processing fragments\",\n        ):\n            gene_ix = var.loc[gene, \"ix\"]\n            start = max(0, promoter_info[\"start\"])\n\n            fragments_promoter = fragments_tabix.fetch(\n                promoter_info[\"chrom\"],\n                start,\n                promoter_info[\"end\"],\n                parser=pysam.asTuple(),\n            )\n\n            for fragment in fragments_promoter:\n                cell = fragment[3]\n\n                # only store the fragment if the cell is actually of interest\n                if cell in cell_to_cell_ix:\n                    # add raw data of fragment relative to tss\n                    coordinates_raw.append(\n                        [\n                            (int(fragment[1]) - promoter_info[\"tss\"])\n                            * promoter_info[\"strand\"],\n                            (int(fragment[2]) - promoter_info[\"tss\"])\n                            * promoter_info[\"strand\"],\n                        ][:: promoter_info[\"strand\"]]\n                    )\n\n                    # add mapping of cell/gene\n                    mapping_raw.append([cell_to_cell_ix[fragment[3]], gene_ix])\n\n        coordinates = torch.tensor(np.array(coordinates_raw, dtype=np.int64))\n        mapping = torch.tensor(np.array(mapping_raw), dtype=torch.int64)\n\n        # Sort `coordinates` and `mapping` according to `mapping`\n        sorted_idx = torch.argsort((mapping[:, 0] * var.shape[0] + mapping[:, 1]))\n        mapping = mapping[sorted_idx]\n        coordinates = coordinates[sorted_idx]\n\n        return cls.create(\n            path=path,\n            coordinates=coordinates,\n            mapping=mapping,\n            regions=regions,\n            var=var,\n            obs=obs,\n        )\n</code></pre> <p>         Bases: <code>Flow</code></p> Source code in <code>src/chromatinhd/data/transcriptome/transcriptome.py</code> <pre><code>class Transcriptome(Flow):\n    _var = None\n\n    @property\n    def var(self):\n        if self._var is None:\n            self._var = pd.read_table(self.path / \"var.tsv\", index_col=0)\n        return self._var\n\n    @var.setter\n    def var(self, value):\n        value.index.name = \"gene\"\n        value.to_csv(self.path / \"var.tsv\", sep=\"\\t\")\n        self._var = value\n\n    _obs = None\n\n    @property\n    def obs(self):\n        if self._obs is None:\n            self._obs = pd.read_table(self.path / \"obs.tsv\", index_col=0)\n        return self._obs\n\n    @obs.setter\n    def obs(self, value):\n        value.index.name = \"cell\"\n        value.to_csv(self.path / \"obs.tsv\", sep=\"\\t\")\n        self._obs = value\n\n    _adata = None\n\n    @property\n    def adata(self):\n        if self._adata is None:\n            self._adata = pickle.load((self.path / \"adata.pkl\").open(\"rb\"))\n        return self._adata\n\n    @adata.setter\n    def adata(self, value):\n        pickle.dump(value, (self.path / \"adata.pkl\").open(\"wb\"))\n        self._adata = value\n\n    def gene_id(self, symbol):\n        assert all(pd.Series(symbol).isin(self.var[\"symbol\"])), set(\n            pd.Series(symbol)[~pd.Series(symbol).isin(self.var[\"symbol\"])]\n        )\n        return self.var.reset_index(\"gene\").set_index(\"symbol\").loc[symbol][\"gene\"]\n\n    def symbol(self, gene_id):\n        assert all(pd.Series(gene_id).isin(self.var.index)), set(\n            pd.Series(gene_id)[~pd.Series(gene_id).isin(self.var.index)]\n        )\n        return self.var.loc[gene_id][\"symbol\"]\n\n    def gene_ix(self, symbol):\n        self.var[\"ix\"] = np.arange(self.var.shape[0])\n        assert all(pd.Series(symbol).isin(self.var[\"symbol\"])), set(\n            pd.Series(symbol)[~pd.Series(symbol).isin(self.var[\"symbol\"])]\n        )\n        return self.var.reset_index(\"gene\").set_index(\"symbol\").loc[symbol][\"ix\"]\n\n    def create_X(self):\n        X_scipy = self.adata.X\n        if isinstance(X_scipy, np.ndarray):\n            import scipy.sparse\n\n            X_scipy = scipy.sparse.csr_matrix(X_scipy)\n        X = sparse.COOMatrix.from_scipy_csr(X_scipy)\n        X.populate_mapping()\n\n        self.X = X\n\n    _X = None\n\n    @property\n    def X(self):\n        if self._X is None:\n            self._X = Unpickler((self.path / \"X.pkl\").open(\"rb\")).load()\n        return self._X\n\n    @X.setter\n    def X(self, value):\n        pickle.dump(value, (self.path / \"X.pkl\").open(\"wb\"))\n        self._X = value\n\n    @classmethod\n    def from_adata(cls, adata, path):\n        transcriptome = cls(path=path)\n        transcriptome.adata = adata\n        transcriptome.layers[\"X\"] = adata.X\n        transcriptome.var = adata.var\n        transcriptome.obs = adata.obs\n        return transcriptome\n\n    layers = StoredDict(\"layers\", Stored)\n</code></pre> <p>         Bases: <code>Flow</code></p> Source code in <code>src/chromatinhd/data/clustering/clustering.py</code> <pre><code>class Clustering(Flow):\n    labels = Stored(\"labels\")\n\"\"\"Labels for each cell.\"\"\"\n\n    cluster_info = Stored(\"cluster_info\")\n\"\"\"Dataframe containing information, such as a label, for each cluster.\"\"\"\n\n    @classmethod\n    def from_labels(cls, labels, path):\n        clustering = cls(path)\n        if not isinstance(labels, pd.Series):\n            labels = pd.Series(labels).astype(\"category\")\n        clustering.labels = labels\n        clustering.cluster_info = (\n            pd.DataFrame(\n                {\n                    \"cluster\": labels.unique(),\n                    \"n_cells\": labels.value_counts(),\n                    \"label\": labels.unique(),\n                }\n            )\n            .set_index(\"cluster\")\n            .loc[labels.cat.categories]\n        )\n        return clustering\n\n    @property\n    def n_clusters(self):\n        return len(self.labels.unique())\n</code></pre>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.cellxgene_indptr","title":"<code>cellxgene_indptr = StoredTorchInt64('cellxgene_indptr')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Index pointers for each cellxgene combination</p>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.coordinates","title":"<code>coordinates = StoredTorchInt64('coordinates')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Coordinates of the fragments</p>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.mapping","title":"<code>mapping = StoredTorchInt64('mapping')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mapping of a fragment to a gene and a cell</p>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.regions","title":"<code>regions = Linked('regions')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>regions of the fragments</p>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.from_fragments_tsv","title":"<code>from_fragments_tsv(fragments_file, regions, obs, path, overwrite=True)</code>  <code>classmethod</code>","text":"<p>Create a Fragments object from a tsv file</p> <p>Parameters:</p> Name Type Description Default <code>fragments_file</code> <code>typing.Union[pathlib.Path, str]</code> <p>fragments_file of the tsv file</p> required <code>path</code> <code>typing.Union[pathlib.Path, str]</code> <p>folder in which the fragments object will be created</p> required <code>regions</code> <code>Regions</code> <p>regions object</p> required Source code in <code>src/chromatinhd/data/fragments/fragments.py</code> <pre><code>@classmethod\ndef from_fragments_tsv(\n    cls,\n    fragments_file: typing.Union[pathlib.Path, str],\n    regions: Regions,\n    obs: pd.DataFrame,\n    path: typing.Union[pathlib.Path, str],\n    overwrite=True,\n):\n\"\"\"\n    Create a Fragments object from a tsv file\n\n    Parameters:\n        fragments_file:\n            fragments_file of the tsv file\n        path:\n            folder in which the fragments object will be created\n        regions:\n            regions object\n    \"\"\"\n\n    if isinstance(fragments_file, str):\n        fragments_file = pathlib.Path(fragments_file)\n    if isinstance(path, str):\n        path = pathlib.Path(path)\n    if not fragments_file.exists():\n        raise FileNotFoundError(f\"File {fragments_file} does not exist\")\n    if not overwrite and path.exists():\n        raise FileExistsError(f\"Folder {path} already exists\")\n    path.mkdir(parents=True, exist_ok=True)\n\n    # region information\n    var = pd.DataFrame(index=regions.coordinates.index)\n    var[\"ix\"] = np.arange(var.shape[0])\n\n    n_genes = var.shape[0]\n\n    # cell information\n    obs[\"ix\"] = np.arange(obs.shape[0])\n    cell_to_cell_ix = obs[\"ix\"].to_dict()\n\n    n_cells = obs.shape[0]\n\n    # load fragments tabix\n    import pysam\n\n    fragments_tabix = pysam.TabixFile(str(fragments_file))\n\n    coordinates_raw = []\n    mapping_raw = []\n\n    for i, (gene, promoter_info) in tqdm.tqdm(\n        enumerate(regions.coordinates.iterrows()),\n        total=regions.coordinates.shape[0],\n        leave=False,\n        desc=\"Processing fragments\",\n    ):\n        gene_ix = var.loc[gene, \"ix\"]\n        start = max(0, promoter_info[\"start\"])\n\n        fragments_promoter = fragments_tabix.fetch(\n            promoter_info[\"chrom\"],\n            start,\n            promoter_info[\"end\"],\n            parser=pysam.asTuple(),\n        )\n\n        for fragment in fragments_promoter:\n            cell = fragment[3]\n\n            # only store the fragment if the cell is actually of interest\n            if cell in cell_to_cell_ix:\n                # add raw data of fragment relative to tss\n                coordinates_raw.append(\n                    [\n                        (int(fragment[1]) - promoter_info[\"tss\"])\n                        * promoter_info[\"strand\"],\n                        (int(fragment[2]) - promoter_info[\"tss\"])\n                        * promoter_info[\"strand\"],\n                    ][:: promoter_info[\"strand\"]]\n                )\n\n                # add mapping of cell/gene\n                mapping_raw.append([cell_to_cell_ix[fragment[3]], gene_ix])\n\n    coordinates = torch.tensor(np.array(coordinates_raw, dtype=np.int64))\n    mapping = torch.tensor(np.array(mapping_raw), dtype=torch.int64)\n\n    # Sort `coordinates` and `mapping` according to `mapping`\n    sorted_idx = torch.argsort((mapping[:, 0] * var.shape[0] + mapping[:, 1]))\n    mapping = mapping[sorted_idx]\n    coordinates = coordinates[sorted_idx]\n\n    return cls.create(\n        path=path,\n        coordinates=coordinates,\n        mapping=mapping,\n        regions=regions,\n        var=var,\n        obs=obs,\n    )\n</code></pre>"},{"location":"reference/data/#chromatinhd.data.clustering.clustering.Clustering.cluster_info","title":"<code>cluster_info = Stored('cluster_info')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dataframe containing information, such as a label, for each cluster.</p>"},{"location":"reference/data/#chromatinhd.data.clustering.clustering.Clustering.labels","title":"<code>labels = Stored('labels')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Labels for each cell.</p>"}]}