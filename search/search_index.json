{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>ChromatinHD analyzes single-cell ATAC+RNA data using the raw fragments as input, by automatically adapting the scale at which relevant chromatin changes on a per-position, per-cell, and per-gene basis.</p> <p>Currently, the following models are supported:</p> <ul> <li>pred: Predicting gene expression from fragments         <ul> <li>To learn where accessibility is predictive for gene                 expression</li> <li>To learn which regions in the genome are likely collaborating to regulate gene expression</li> <li>To learn for which regions high fragment sizes are indicative of gene expression, which indicates an active regulatory region with dense protein binding</li> </ul> </li> <li>diff: Understanding the differences in accessibilty between cell types/states</li> </ul>"},{"location":"reference/data/","title":"Data","text":"<p>             Bases: <code>Flow</code></p> <p>Regions, typically centered around a transcription start site</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/chromatinhd/data/regions.py</code> <pre><code>class Regions(Flow):\n\"\"\"\n    Regions, typically centered around a transcription start site\n    \"\"\"\n\n    coordinates = TSV(\"coordinates\", columns=[\"chrom\", \"start\", \"end\"])\n    window = Stored(\"window\")\n\n    @classmethod\n    def from_canonical_transcripts(\n        cls, canonical_transcripts: pd.DataFrame, window: np.ndarray, path: pathlib.Path\n    ):\n        regions = canonical_transcripts[\n            [\"chrom\", \"start\", \"end\", \"ensembl_transcript_id\"]\n        ].copy()\n\n        regions[\"tss\"] = [\n            genes_row[\"start\"] if genes_row[\"strand\"] == +1 else genes_row[\"end\"]\n            for _, genes_row in canonical_transcripts.loc[regions.index].iterrows()\n        ]\n        regions[\"strand\"] = canonical_transcripts[\"strand\"]\n        regions[\"positive_strand\"] = (regions[\"strand\"] == 1).astype(int)\n        regions[\"negative_strand\"] = (regions[\"strand\"] == -1).astype(int)\n        regions[\"chrom\"] = canonical_transcripts.loc[regions.index, \"chrom\"]\n\n        regions[\"start\"] = (\n            regions[\"tss\"]\n            + window[0] * (regions[\"strand\"] == 1)\n            - window[1] * (regions[\"strand\"] == -1)\n        )\n        regions[\"end\"] = (\n            regions[\"tss\"]\n            + window[1] * (regions[\"strand\"] == -1)\n            - window[0] * (regions[\"strand\"] == 1)\n        )\n\n        return cls.create(\n            path=path,\n            coordinates=regions[\n                [\"chrom\", \"start\", \"end\", \"tss\", \"strand\", \"ensembl_transcript_id\"]\n            ],\n            window=window,\n        )\n</code></pre> <p>             Bases: <code>Flow</code></p> <p>Fragments centered around a gene window</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/chromatinhd/data/fragments/fragments.py</code> <pre><code>class Fragments(Flow):\n\"\"\"\n    Fragments centered around a gene window\n    \"\"\"\n\n    regions = Linked(\"regions\")\n\"\"\"regions of the fragments\"\"\"\n\n    coordinates = StoredTorchInt64(\"coordinates\")\n\"\"\"Coordinates of the fragments\"\"\"\n\n    mapping = StoredTorchInt64(\"mapping\")\n\"\"\"Mapping of a fragment to a gene and a cell\"\"\"\n\n    cellxgene_indptr = StoredTorchInt64(\"cellxgene_indptr\")\n\"\"\"Index pointers for each cellxgene combination\"\"\"\n\n    regions = Linked(\"regions\")\n\n    def create_cellxgene_indptr(self):\n        cellxgene = self.mapping[:, 0] * self.n_genes + self.mapping[:, 1]\n\n        if not (cellxgene.diff() &gt;= 0).all():\n            raise ValueError(\n                \"Fragments should be ordered by cell then gene (ascending)\"\n            )\n\n        n_cellxgene = self.n_genes * self.n_cells\n        cellxgene_indptr = torch.nn.functional.pad(\n            torch.cumsum(torch.bincount(cellxgene, minlength=n_cellxgene), 0), (1, 0)\n        )\n        assert self.coordinates.shape[0] == cellxgene_indptr[-1]\n        if not (cellxgene_indptr.diff() &gt;= 0).all():\n            raise ValueError(\n                \"Fragments should be ordered by cell then gene (ascending)\"\n            )\n        self.cellxgene_indptr = cellxgene_indptr\n\n    _genemapping = None\n\n    @property\n    def genemapping(self):\n        if self._genemapping is None:\n            self._genemapping = self.mapping[:, 1].contiguous()\n        return self._genemapping\n\n    _cellmapping = None\n\n    @property\n    def cellmapping(self):\n        if self._cellmapping is None:\n            self._cellmapping = self.mapping[:, 0].contiguous()\n        return self._cellmapping\n\n    var = TSV(\"var\")\n    obs = TSV(\"obs\")\n\n    _n_genes = None\n\n    @property\n    def n_genes(self):\n        if self._n_genes is None:\n            self._n_genes = self.var.shape[0]\n        return self._n_genes\n\n    _n_cells = None\n\n    @property\n    def n_cells(self):\n        if self._n_cells is None:\n            self._n_cells = self.obs.shape[0]\n        return self._n_cells\n\n    @property\n    def local_cellxgene_ix(self):\n        return self.cellmapping * self.n_genes + self.genemapping\n\n    def estimate_fragment_per_cellxgene(self):\n        return math.ceil(self.coordinates.shape[0] / self.n_cells / self.n_genes * 2)\n\n    def create_cut_data(self):\n        cut_coordinates = self.coordinates.flatten()\n        cut_coordinates = (cut_coordinates - self.window[0]) / (\n            self.window[1] - self.window[0]\n        )\n        keep_cuts = (cut_coordinates &gt;= 0) &amp; (cut_coordinates &lt;= 1)\n        cut_coordinates = cut_coordinates[keep_cuts]\n\n        self.cut_coordinates = cut_coordinates\n\n        self.cut_local_gene_ix = self.genemapping.expand(2, -1).T.flatten()[keep_cuts]\n        self.cut_local_cell_ix = self.cellmapping.expand(2, -1).T.flatten()[keep_cuts]\n\n    @property\n    def genes_oi_torch(self):\n        return torch.from_numpy(self.genes_oi).to(self.coordinates.device)\n\n    @property\n    def cells_oi_torch(self):\n        return torch.from_numpy(self.genes_oi).to(self.coordinates.device)\n\n    @classmethod\n    def from_fragments_tsv(\n        cls,\n        fragments_file: typing.Union[pathlib.Path, str],\n        regions: Regions,\n        obs: pd.DataFrame,\n        path: typing.Union[pathlib.Path, str],\n        overwrite=True,\n    ):\n\"\"\"\n        Create a Fragments object from a tsv file\n\n        Parameters:\n            fragments_file:\n                fragments_file of the tsv file\n            path:\n                folder in which the fragments object will be created\n            regions:\n                regions object\n        \"\"\"\n\n        if isinstance(fragments_file, str):\n            fragments_file = pathlib.Path(fragments_file)\n        if isinstance(path, str):\n            path = pathlib.Path(path)\n        if not fragments_file.exists():\n            raise FileNotFoundError(f\"File {fragments_file} does not exist\")\n        if not overwrite and path.exists():\n            raise FileExistsError(f\"Folder {path} already exists\")\n        path.mkdir(parents=True, exist_ok=True)\n\n        # region information\n        var = pd.DataFrame(index=regions.coordinates.index)\n        var[\"ix\"] = np.arange(var.shape[0])\n\n        n_genes = var.shape[0]\n\n        # cell information\n        obs[\"ix\"] = np.arange(obs.shape[0])\n        cell_to_cell_ix = obs[\"ix\"].to_dict()\n\n        n_cells = obs.shape[0]\n\n        # load fragments tabix\n        import pysam\n\n        fragments_tabix = pysam.TabixFile(str(fragments_file))\n\n        coordinates_raw = []\n        mapping_raw = []\n\n        for i, (gene, promoter_info) in tqdm.tqdm(\n            enumerate(regions.coordinates.iterrows()),\n            total=regions.coordinates.shape[0],\n            leave=False,\n            desc=\"Processing fragments\",\n        ):\n            gene_ix = var.loc[gene, \"ix\"]\n            start = max(0, promoter_info[\"start\"])\n\n            fragments_promoter = fragments_tabix.fetch(\n                promoter_info[\"chrom\"],\n                start,\n                promoter_info[\"end\"],\n                parser=pysam.asTuple(),\n            )\n\n            for fragment in fragments_promoter:\n                cell = fragment[3]\n\n                # only store the fragment if the cell is actually of interest\n                if cell in cell_to_cell_ix:\n                    # add raw data of fragment relative to tss\n                    coordinates_raw.append(\n                        [\n                            (int(fragment[1]) - promoter_info[\"tss\"])\n                            * promoter_info[\"strand\"],\n                            (int(fragment[2]) - promoter_info[\"tss\"])\n                            * promoter_info[\"strand\"],\n                        ][:: promoter_info[\"strand\"]]\n                    )\n\n                    # add mapping of cell/gene\n                    mapping_raw.append([cell_to_cell_ix[fragment[3]], gene_ix])\n\n        coordinates = torch.tensor(np.array(coordinates_raw, dtype=np.int64))\n        mapping = torch.tensor(np.array(mapping_raw), dtype=torch.int64)\n\n        # Sort `coordinates` and `mapping` according to `mapping`\n        sorted_idx = torch.argsort((mapping[:, 0] * var.shape[0] + mapping[:, 1]))\n        mapping = mapping[sorted_idx]\n        coordinates = coordinates[sorted_idx]\n\n        return cls.create(\n            path=path,\n            coordinates=coordinates,\n            mapping=mapping,\n            regions=regions,\n            var=var,\n            obs=obs,\n        )\n</code></pre> <p>             Bases: <code>Flow</code></p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/chromatinhd/data/transcriptome/transcriptome.py</code> <pre><code>class Transcriptome(Flow):\n    _var = None\n\n    @property\n    def var(self):\n        if self._var is None:\n            self._var = pd.read_table(self.path / \"var.tsv\", index_col=0)\n        return self._var\n\n    @var.setter\n    def var(self, value):\n        value.index.name = \"gene\"\n        value.to_csv(self.path / \"var.tsv\", sep=\"\\t\")\n        self._var = value\n\n    _obs = None\n\n    @property\n    def obs(self):\n        if self._obs is None:\n            self._obs = pd.read_table(self.path / \"obs.tsv\", index_col=0)\n        return self._obs\n\n    @obs.setter\n    def obs(self, value):\n        value.index.name = \"cell\"\n        value.to_csv(self.path / \"obs.tsv\", sep=\"\\t\")\n        self._obs = value\n\n    _adata = None\n\n    @property\n    def adata(self):\n        if self._adata is None:\n            self._adata = pickle.load((self.path / \"adata.pkl\").open(\"rb\"))\n        return self._adata\n\n    @adata.setter\n    def adata(self, value):\n        pickle.dump(value, (self.path / \"adata.pkl\").open(\"wb\"))\n        self._adata = value\n\n    def gene_id(self, symbol):\n        assert all(pd.Series(symbol).isin(self.var[\"symbol\"])), set(\n            pd.Series(symbol)[~pd.Series(symbol).isin(self.var[\"symbol\"])]\n        )\n        return self.var.reset_index(\"gene\").set_index(\"symbol\").loc[symbol][\"gene\"]\n\n    def symbol(self, gene_id):\n        assert all(pd.Series(gene_id).isin(self.var.index)), set(\n            pd.Series(gene_id)[~pd.Series(gene_id).isin(self.var.index)]\n        )\n        return self.var.loc[gene_id][\"symbol\"]\n\n    def gene_ix(self, symbol):\n        self.var[\"ix\"] = np.arange(self.var.shape[0])\n        assert all(pd.Series(symbol).isin(self.var[\"symbol\"])), set(\n            pd.Series(symbol)[~pd.Series(symbol).isin(self.var[\"symbol\"])]\n        )\n        return self.var.reset_index(\"gene\").set_index(\"symbol\").loc[symbol][\"ix\"]\n\n    def create_X(self):\n        X_scipy = self.adata.X\n        if isinstance(X_scipy, np.ndarray):\n            import scipy.sparse\n\n            X_scipy = scipy.sparse.csr_matrix(X_scipy)\n        X = sparse.COOMatrix.from_scipy_csr(X_scipy)\n        X.populate_mapping()\n\n        self.X = X\n\n    _X = None\n\n    @property\n    def X(self):\n        if self._X is None:\n            self._X = Unpickler((self.path / \"X.pkl\").open(\"rb\")).load()\n        return self._X\n\n    @X.setter\n    def X(self, value):\n        pickle.dump(value, (self.path / \"X.pkl\").open(\"wb\"))\n        self._X = value\n\n    @classmethod\n    def from_adata(cls, adata, path):\n        transcriptome = cls(path=path)\n        transcriptome.adata = adata\n        transcriptome.layers[\"X\"] = adata.X\n        transcriptome.var = adata.var\n        transcriptome.obs = adata.obs\n        return transcriptome\n\n    layers = StoredDict(\"layers\", Stored)\n</code></pre>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.cellxgene_indptr","title":"<code>cellxgene_indptr = StoredTorchInt64('cellxgene_indptr')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Index pointers for each cellxgene combination</p>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.coordinates","title":"<code>coordinates = StoredTorchInt64('coordinates')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Coordinates of the fragments</p>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.mapping","title":"<code>mapping = StoredTorchInt64('mapping')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mapping of a fragment to a gene and a cell</p>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.regions","title":"<code>regions = Linked('regions')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>regions of the fragments</p>"},{"location":"reference/data/#chromatinhd.data.fragments.fragments.Fragments.from_fragments_tsv","title":"<code>from_fragments_tsv(fragments_file, regions, obs, path, overwrite=True)</code>  <code>classmethod</code>","text":"<p>Create a Fragments object from a tsv file</p> <p>Parameters:</p> Name Type Description Default <code>fragments_file</code> <code>typing.Union[pathlib.Path, str]</code> <p>fragments_file of the tsv file</p> required <code>path</code> <code>typing.Union[pathlib.Path, str]</code> <p>folder in which the fragments object will be created</p> required <code>regions</code> <code>Regions</code> <p>regions object</p> required Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/chromatinhd/data/fragments/fragments.py</code> <pre><code>@classmethod\ndef from_fragments_tsv(\n    cls,\n    fragments_file: typing.Union[pathlib.Path, str],\n    regions: Regions,\n    obs: pd.DataFrame,\n    path: typing.Union[pathlib.Path, str],\n    overwrite=True,\n):\n\"\"\"\n    Create a Fragments object from a tsv file\n\n    Parameters:\n        fragments_file:\n            fragments_file of the tsv file\n        path:\n            folder in which the fragments object will be created\n        regions:\n            regions object\n    \"\"\"\n\n    if isinstance(fragments_file, str):\n        fragments_file = pathlib.Path(fragments_file)\n    if isinstance(path, str):\n        path = pathlib.Path(path)\n    if not fragments_file.exists():\n        raise FileNotFoundError(f\"File {fragments_file} does not exist\")\n    if not overwrite and path.exists():\n        raise FileExistsError(f\"Folder {path} already exists\")\n    path.mkdir(parents=True, exist_ok=True)\n\n    # region information\n    var = pd.DataFrame(index=regions.coordinates.index)\n    var[\"ix\"] = np.arange(var.shape[0])\n\n    n_genes = var.shape[0]\n\n    # cell information\n    obs[\"ix\"] = np.arange(obs.shape[0])\n    cell_to_cell_ix = obs[\"ix\"].to_dict()\n\n    n_cells = obs.shape[0]\n\n    # load fragments tabix\n    import pysam\n\n    fragments_tabix = pysam.TabixFile(str(fragments_file))\n\n    coordinates_raw = []\n    mapping_raw = []\n\n    for i, (gene, promoter_info) in tqdm.tqdm(\n        enumerate(regions.coordinates.iterrows()),\n        total=regions.coordinates.shape[0],\n        leave=False,\n        desc=\"Processing fragments\",\n    ):\n        gene_ix = var.loc[gene, \"ix\"]\n        start = max(0, promoter_info[\"start\"])\n\n        fragments_promoter = fragments_tabix.fetch(\n            promoter_info[\"chrom\"],\n            start,\n            promoter_info[\"end\"],\n            parser=pysam.asTuple(),\n        )\n\n        for fragment in fragments_promoter:\n            cell = fragment[3]\n\n            # only store the fragment if the cell is actually of interest\n            if cell in cell_to_cell_ix:\n                # add raw data of fragment relative to tss\n                coordinates_raw.append(\n                    [\n                        (int(fragment[1]) - promoter_info[\"tss\"])\n                        * promoter_info[\"strand\"],\n                        (int(fragment[2]) - promoter_info[\"tss\"])\n                        * promoter_info[\"strand\"],\n                    ][:: promoter_info[\"strand\"]]\n                )\n\n                # add mapping of cell/gene\n                mapping_raw.append([cell_to_cell_ix[fragment[3]], gene_ix])\n\n    coordinates = torch.tensor(np.array(coordinates_raw, dtype=np.int64))\n    mapping = torch.tensor(np.array(mapping_raw), dtype=torch.int64)\n\n    # Sort `coordinates` and `mapping` according to `mapping`\n    sorted_idx = torch.argsort((mapping[:, 0] * var.shape[0] + mapping[:, 1]))\n    mapping = mapping[sorted_idx]\n    coordinates = coordinates[sorted_idx]\n\n    return cls.create(\n        path=path,\n        coordinates=coordinates,\n        mapping=mapping,\n        regions=regions,\n        var=var,\n        obs=obs,\n    )\n</code></pre>"}]}